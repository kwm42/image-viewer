# 图片查看器开发指南

## 快速开始

### 环境要求
- Node.js 18+
- pnpm 8+
- Chrome/Edge 86+ 浏览器（开发和使用）

### 安装依赖

```bash
# 安装项目依赖
pnpm install

# 安装新增的 UI 组件
pnpm add @radix-ui/react-dialog @radix-ui/react-scroll-area @radix-ui/react-slider @radix-ui/react-select @radix-ui/react-switch @radix-ui/react-collapsible

# 安装动画库
pnpm add framer-motion

# 安装工具库
pnpm add clsx tailwind-merge

# 安装虚拟滚动（可选）
pnpm add react-window @types/react-window
```

### 启动开发服务器

```bash
pnpm dev
```

访问 http://localhost:3000

### 构建生产版本

```bash
# 构建静态站点
pnpm build

# 预览构建结果
pnpm start
# 或
npx serve out
```

---

## 开发流程

### Phase 1: 基础架构搭建

#### 1.1 创建项目结构

```bash
# 创建目录
mkdir -p components/{FolderTree,ImageGallery,ImageViewer,Slideshow,Toolbar,ui}
mkdir -p hooks lib types contexts

# 创建文件
touch components/FolderTree/{FolderTree,FolderNode}.tsx
touch components/ImageGallery/{ImageGallery,ImageCard,ImageGrid,ImageList,ViewModeToggle}.tsx
touch components/ImageViewer/{ImageViewer,ImageControls,ImageNavigation,ImageInfo}.tsx
touch components/Slideshow/{Slideshow,SlideshowSettings,SlideshowControls,transitions}.ts
touch components/Toolbar/Toolbar.tsx
touch components/ui/{Button,IconButton,Separator}.tsx

touch hooks/{useFileSystem,useImageLoader,useKeyboardShortcuts,useLocalStorage}.ts
touch lib/{fileUtils,imageUtils,constants}.ts
touch types/index.ts
touch contexts/AppContext.tsx
```

#### 1.2 配置 Next.js 静态导出

```javascript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  images: {
    unoptimized: true,
  },
};

module.exports = nextConfig;
```

#### 1.3 配置 Tailwind CSS

```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      animation: {
        'fade-in': 'fadeIn 0.3s ease-in-out',
        'slide-in': 'slideIn 0.3s ease-in-out',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideIn: {
          '0%': { transform: 'translateX(100%)' },
          '100%': { transform: 'translateX(0)' },
        },
      },
    },
  },
  plugins: [],
};
```

---

### Phase 2: 核心功能实现

#### 2.1 File System Access API 封装

创建 `hooks/useFileSystem.ts`：

```typescript
import { useState, useCallback } from 'react';
import type { ImageFile, FolderNode } from '@/types';

export function useFileSystem() {
  const [isSupported, setIsSupported] = useState(
    typeof window !== 'undefined' && 'showDirectoryPicker' in window
  );

  // 打开文件夹
  const openFolder = useCallback(async () => {
    if (!isSupported) {
      alert('您的浏览器不支持 File System Access API，请使用 Chrome 或 Edge 浏览器');
      return null;
    }

    try {
      const handle = await window.showDirectoryPicker({
        mode: 'read',
        startIn: 'pictures',
      });
      return handle;
    } catch (err: any) {
      if (err.name !== 'AbortError') {
        console.error('打开文件夹失败:', err);
      }
      return null;
    }
  }, [isSupported]);

  // 扫描文件夹（非递归）
  const scanFolder = useCallback(
    async (
      dirHandle: FileSystemDirectoryHandle,
      parentPath = ''
    ): Promise<{ folders: FolderNode[]; images: ImageFile[] }> => {
      const folders: FolderNode[] = [];
      const images: ImageFile[] = [];

      try {
        for await (const entry of dirHandle.values()) {
          const entryPath = parentPath ? `${parentPath}/${entry.name}` : entry.name;

          if (entry.kind === 'directory') {
            const imageCount = await countImages(entry);
            folders.push({
              id: crypto.randomUUID(),
              name: entry.name,
              handle: entry,
              path: entryPath,
              children: [],
              imageCount,
              totalImageCount: imageCount,
              isExpanded: false,
              isLoaded: false,
              level: parentPath.split('/').filter(Boolean).length,
            });
          } else if (entry.kind === 'file') {
            if (isImageFile(entry.name)) {
              try {
                const file = await entry.getFile();
                const imageFile = await createImageFile(file, entry, entryPath);
                images.push(imageFile);
              } catch (err) {
                console.error(`读取文件失败: ${entry.name}`, err);
              }
            }
          }
        }
      } catch (err) {
        console.error('扫描文件夹失败:', err);
      }

      return { folders, images };
    },
    []
  );

  // 递归扫描所有子文件夹
  const scanFolderRecursive = useCallback(
    async (
      dirHandle: FileSystemDirectoryHandle,
      parentPath = ''
    ): Promise<ImageFile[]> => {
      const allImages: ImageFile[] = [];

      const { folders, images } = await scanFolder(dirHandle, parentPath);
      allImages.push(...images);

      // 递归扫描子文件夹
      for (const folder of folders) {
        const subImages = await scanFolderRecursive(folder.handle, folder.path);
        allImages.push(...subImages);
      }

      return allImages;
    },
    [scanFolder]
  );

  return {
    isSupported,
    openFolder,
    scanFolder,
    scanFolderRecursive,
  };
}

// 工具函数
const IMAGE_EXTENSIONS = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.svg', '.avif'];

function isImageFile(filename: string): boolean {
  const ext = filename.toLowerCase().slice(filename.lastIndexOf('.'));
  return IMAGE_EXTENSIONS.includes(ext);
}

async function countImages(dirHandle: FileSystemDirectoryHandle): Promise<number> {
  let count = 0;
  try {
    for await (const entry of dirHandle.values()) {
      if (entry.kind === 'file' && isImageFile(entry.name)) {
        count++;
      }
    }
  } catch (err) {
    console.error('统计图片数量失败:', err);
  }
  return count;
}

async function createImageFile(
  file: File,
  handle: FileSystemFileHandle,
  path: string
): Promise<ImageFile> {
  const url = URL.createObjectURL(file);
  const dimensions = await getImageDimensions(url);
  const thumbnail = await createThumbnail(url, 300);

  return {
    id: crypto.randomUUID(),
    name: file.name,
    handle,
    path,
    blob: file,
    url,
    thumbnail,
    size: file.size,
    width: dimensions.width,
    height: dimensions.height,
    type: file.type,
    createdAt: new Date(file.lastModified),
    modifiedAt: new Date(file.lastModified),
    folderPath: path.slice(0, path.lastIndexOf('/')),
  };
}

function getImageDimensions(url: string): Promise<{ width: number; height: number }> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
    img.onerror = reject;
    img.src = url;
  });
}

async function createThumbnail(url: string, maxSize: number): Promise<string> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) {
          resolve(url);
          return;
        }

        const scale = Math.min(maxSize / img.naturalWidth, maxSize / img.naturalHeight, 1);
        canvas.width = img.naturalWidth * scale;
        canvas.height = img.naturalHeight * scale;

        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        resolve(canvas.toDataURL('image/jpeg', 0.8));
      } catch (err) {
        resolve(url);
      }
    };
    img.onerror = () => resolve(url);
    img.src = url;
  });
}
```

#### 2.2 类型定义

创建 `types/index.ts`：

```typescript
// 文件夹节点
export interface FolderNode {
  id: string;
  name: string;
  handle: FileSystemDirectoryHandle;
  path: string;
  children: FolderNode[];
  imageCount: number;
  totalImageCount: number;
  isExpanded: boolean;
  isLoaded: boolean;
  level: number;
}

// 图片文件
export interface ImageFile {
  id: string;
  name: string;
  handle: FileSystemFileHandle;
  path: string;
  blob: Blob | null;
  url: string;
  thumbnail: string;
  size: number;
  width: number;
  height: number;
  type: string;
  createdAt: Date;
  modifiedAt: Date;
  folderPath: string;
}

// 视图模式
export type ViewMode = 'grid' | 'list';

// 排序方式
export type SortBy = 'name' | 'date' | 'size' | 'type';
export type SortOrder = 'asc' | 'desc';

// 画廊设置
export interface GallerySettings {
  viewMode: ViewMode;
  sortBy: SortBy;
  sortOrder: SortOrder;
  recursive: boolean;
  gridColumns: number;
}

// 图片变换
export type FitMode = 'contain' | 'cover' | 'actual' | 'custom';

export interface ImageTransform {
  scale: number;
  rotation: number;
  translateX: number;
  translateY: number;
  fitMode: FitMode;
}

// 预览器状态
export interface ImageViewerState {
  isOpen: boolean;
  currentImage: ImageFile | null;
  currentIndex: number;
  images: ImageFile[];
  transform: ImageTransform;
  isLoading: boolean;
}

// 幻灯片转换类型
export type TransitionType = 'none' | 'fade' | 'slide' | 'zoom' | 'flip' | 'dissolve';

// 幻灯片设置
export interface SlideshowSettings {
  interval: number;
  transition: TransitionType;
  transitionDuration: number;
  loop: boolean;
  random: boolean;
  autoFullscreen: boolean;
  showInfo: boolean;
  showProgress: boolean;
}

// 幻灯片状态
export interface SlideshowState {
  isPlaying: boolean;
  isPaused: boolean;
  currentIndex: number;
  progress: number;
  remainingTime: number;
}
```

#### 2.3 应用上下文

创建 `contexts/AppContext.tsx`：

```typescript
'use client';

import React, { createContext, useContext, useState, useCallback, ReactNode } from 'react';
import type {
  FolderNode,
  ImageFile,
  GallerySettings,
  ImageViewerState,
  SlideshowState,
  SlideshowSettings,
} from '@/types';
import { useFileSystem } from '@/hooks/useFileSystem';

interface AppState {
  rootFolder: FolderNode | null;
  selectedFolder: FolderNode | null;
  allImages: ImageFile[];
  filteredImages: ImageFile[];
  gallerySettings: GallerySettings;
  viewerState: ImageViewerState;
  slideshowState: SlideshowState;
  slideshowSettings: SlideshowSettings;
  isLoading: boolean;
  error: string | null;
}

interface AppActions {
  openFolder: () => Promise<void>;
  selectFolder: (folder: FolderNode) => void;
  toggleFolder: (folder: FolderNode) => Promise<void>;
  updateGallerySettings: (settings: Partial<GallerySettings>) => void;
  openImageViewer: (image: ImageFile, index: number) => void;
  closeImageViewer: () => void;
  navigateImage: (direction: 'prev' | 'next') => void;
  startSlideshow: () => void;
  stopSlideshow: () => void;
  updateSlideshowSettings: (settings: Partial<SlideshowSettings>) => void;
}

const AppContext = createContext<(AppState & AppActions) | null>(null);

const initialGallerySettings: GallerySettings = {
  viewMode: 'grid',
  sortBy: 'name',
  sortOrder: 'asc',
  recursive: false,
  gridColumns: 4,
};

const initialViewerState: ImageViewerState = {
  isOpen: false,
  currentImage: null,
  currentIndex: 0,
  images: [],
  transform: {
    scale: 1,
    rotation: 0,
    translateX: 0,
    translateY: 0,
    fitMode: 'contain',
  },
  isLoading: false,
};

const initialSlideshowSettings: SlideshowSettings = {
  interval: 3000,
  transition: 'fade',
  transitionDuration: 500,
  loop: true,
  random: false,
  autoFullscreen: true,
  showInfo: true,
  showProgress: true,
};

const initialSlideshowState: SlideshowState = {
  isPlaying: false,
  isPaused: false,
  currentIndex: 0,
  progress: 0,
  remainingTime: 0,
};

export function AppProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<AppState>({
    rootFolder: null,
    selectedFolder: null,
    allImages: [],
    filteredImages: [],
    gallerySettings: initialGallerySettings,
    viewerState: initialViewerState,
    slideshowState: initialSlideshowState,
    slideshowSettings: initialSlideshowSettings,
    isLoading: false,
    error: null,
  });

  const { openFolder: openFolderDialog, scanFolder, scanFolderRecursive } = useFileSystem();

  // 打开文件夹
  const openFolder = useCallback(async () => {
    setState((prev) => ({ ...prev, isLoading: true, error: null }));

    const handle = await openFolderDialog();
    if (!handle) {
      setState((prev) => ({ ...prev, isLoading: false }));
      return;
    }

    try {
      const { folders, images } = await scanFolder(handle);

      const rootNode: FolderNode = {
        id: crypto.randomUUID(),
        name: handle.name,
        handle,
        path: '',
        children: folders,
        imageCount: images.length,
        totalImageCount: images.length,
        isExpanded: true,
        isLoaded: true,
        level: 0,
      };

      setState((prev) => ({
        ...prev,
        rootFolder: rootNode,
        selectedFolder: rootNode,
        allImages: images,
        filteredImages: images,
        isLoading: false,
      }));
    } catch (err: any) {
      setState((prev) => ({
        ...prev,
        error: err.message || '打开文件夹失败',
        isLoading: false,
      }));
    }
  }, [openFolderDialog, scanFolder]);

  // 其他 actions 实现...
  // (selectFolder, toggleFolder, updateGallerySettings, etc.)

  const value: AppState & AppActions = {
    ...state,
    openFolder,
    selectFolder: () => {},
    toggleFolder: async () => {},
    updateGallerySettings: () => {},
    openImageViewer: () => {},
    closeImageViewer: () => {},
    navigateImage: () => {},
    startSlideshow: () => {},
    stopSlideshow: () => {},
    updateSlideshowSettings: () => {},
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

export function useApp() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within AppProvider');
  }
  return context;
}
```

---

### Phase 3: UI 组件开发

#### 3.1 文件夹树组件

创建 `components/FolderTree/FolderNode.tsx`：

```typescript
'use client';

import React from 'react';
import { ChevronRightIcon } from '@radix-ui/react-icons';
import * as Collapsible from '@radix-ui/react-collapsible';
import type { FolderNode as FolderNodeType } from '@/types';
import { cn } from '@/lib/utils';

interface FolderNodeProps {
  folder: FolderNodeType;
  isSelected: boolean;
  onSelect: () => void;
  onToggle: () => void;
  level: number;
}

export function FolderNode({ folder, isSelected, onSelect, onToggle, level }: FolderNodeProps) {
  return (
    <Collapsible.Root open={folder.isExpanded} onOpenChange={onToggle}>
      <div
        className={cn(
          'flex items-center gap-1 px-2 py-1 rounded cursor-pointer select-none',
          'hover:bg-gray-100 dark:hover:bg-gray-800',
          isSelected && 'bg-blue-100 dark:bg-blue-900'
        )}
        style={{ paddingLeft: `${level * 1 + 0.5}rem` }}
        onClick={onSelect}
      >
        <Collapsible.Trigger
          className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded"
          onClick={(e) => {
            e.stopPropagation();
            onToggle();
          }}
        >
          <ChevronRightIcon
            className={cn(
              'w-4 h-4 transition-transform',
              folder.isExpanded && 'rotate-90'
            )}
          />
        </Collapsible.Trigger>

        <span className="flex-1 text-sm truncate">{folder.name}</span>
        
        <span className="text-xs text-gray-500">{folder.imageCount}</span>
      </div>

      <Collapsible.Content>
        {folder.children.map((child) => (
          <FolderNode
            key={child.id}
            folder={child}
            isSelected={false}
            onSelect={() => {}}
            onToggle={() => {}}
            level={level + 1}
          />
        ))}
      </Collapsible.Content>
    </Collapsible.Root>
  );
}
```

#### 3.2 图片卡片组件

创建 `components/ImageGallery/ImageCard.tsx`：

```typescript
'use client';

import React from 'react';
import Image from 'next/image';
import type { ImageFile } from '@/types';
import { cn } from '@/lib/utils';
import { formatFileSize } from '@/lib/utils';

interface ImageCardProps {
  image: ImageFile;
  onClick: () => void;
  isSelected?: boolean;
}

export function ImageCard({ image, onClick, isSelected }: ImageCardProps) {
  return (
    <div
      className={cn(
        'group relative aspect-square overflow-hidden rounded-lg cursor-pointer',
        'transition-transform hover:scale-105',
        'hover:shadow-lg',
        isSelected && 'ring-2 ring-blue-500'
      )}
      onClick={onClick}
    >
      <img
        src={image.thumbnail}
        alt={image.name}
        className="w-full h-full object-cover"
      />

      {/* 悬停信息覆层 */}
      <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex flex-col justify-end p-2">
        <p className="text-white text-sm font-medium truncate">{image.name}</p>
        <p className="text-white/80 text-xs">
          {image.width} × {image.height}
        </p>
        <p className="text-white/80 text-xs">{formatFileSize(image.size)}</p>
      </div>
    </div>
  );
}
```

---

## 调试技巧

### 1. 浏览器开发者工具

```javascript
// 在控制台检查 File System API 支持
console.log('File System Access API:', 'showDirectoryPicker' in window);

// 查看当前加载的图片
console.table(images.map(img => ({
  name: img.name,
  size: `${(img.size / 1024).toFixed(2)} KB`,
  dimensions: `${img.width}×${img.height}`
})));
```

### 2. React DevTools

安装 React DevTools 扩展，检查组件状态和 props。

### 3. 性能分析

```javascript
// 使用 Performance API 测量加载时间
performance.mark('start-load-images');
await loadImages();
performance.mark('end-load-images');
performance.measure('load-images', 'start-load-images', 'end-load-images');

const measure = performance.getEntriesByName('load-images')[0];
console.log(`加载图片耗时: ${measure.duration.toFixed(2)}ms`);
```

---

## 常见问题

### Q1: File System Access API 不工作？

**A:** 确保使用支持的浏览器（Chrome/Edge 86+），并且页面通过 HTTP/HTTPS 或 file:// 协议访问。

### Q2: 图片加载很慢？

**A:** 
- 检查缩略图生成是否正常
- 使用虚拟滚动优化大量图片
- 实现懒加载和预加载策略

### Q3: 内存占用过高？

**A:**
- 及时调用 `URL.revokeObjectURL()` 释放对象
- 限制同时加载的图片数量
- 使用 WeakMap 存储临时数据

### Q4: 幻灯片播放卡顿？

**A:**
- 预加载前后几张图片
- 使用 CSS transform 代替位置属性
- 减少动画复杂度

---

## 代码规范

### 命名约定
- 组件: PascalCase (`ImageCard`)
- 函数: camelCase (`loadImages`)
- 常量: UPPER_SNAKE_CASE (`IMAGE_EXTENSIONS`)
- 类型: PascalCase (`ImageFile`)

### 文件组织
- 一个文件一个组件
- 相关组件放在同一目录
- 使用 `index.ts` 导出

### 注释规范
```typescript
/**
 * 加载文件夹内的所有图片
 * @param dirHandle 文件夹句柄
 * @param recursive 是否递归扫描子文件夹
 * @returns 图片文件数组
 */
async function loadImages(
  dirHandle: FileSystemDirectoryHandle,
  recursive: boolean
): Promise<ImageFile[]> {
  // 实现...
}
```

---

## 资源链接

- [Next.js 文档](https://nextjs.org/docs)
- [Radix UI 文档](https://www.radix-ui.com/docs)
- [Tailwind CSS 文档](https://tailwindcss.com/docs)
- [Framer Motion 文档](https://www.framer.com/motion/)
- [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API)
